### 动态规划（Dynamic Programming）

#### 概念：

动态规划是一种通过将复杂问题分解为更小的子问题，并保存这些子问题的结果，来避免重复计算，从而提高效率的算法设计范式。动态规划通常适用于具有**重叠子问题**和**最优子结构**的问题。

- **重叠子问题**：问题可以分解为相互重叠的子问题。即同一个子问题会被多次计算。
- **最优子结构**：问题的最优解可以通过其子问题的最优解构成。

#### 两种常见的动态规划方法：

1. **自顶向下（记忆化递归）**：通过递归将问题分解，并使用数组（或其他结构）记录子问题的解，以避免重复计算。
2. **自底向上（迭代法）**：通过填表的方式从小问题逐步求解出大问题。

#### 动态规划的常见步骤：

1. **定义状态**：明确每一个状态（即子问题）的含义，通常通过 `dp[i]` 来表示。
2. **状态转移方程**：定义从一个状态到另一个状态的递推关系，即如何通过子问题的解推导出更大的问题的解。
3. **初始化**：为子问题的初始状态赋值。
4. **遍历顺序**：根据递推关系，确定遍历的顺序（通常是线性、矩阵等形式）。
5. **返回结果**：返回最终的全局问题的解。

### 经典例子：斐波那契数列

#### 问题描述：

给定一个整数 `n`，要求计算斐波那契数列的第 `n` 项。斐波那契数列的定义如下：

- `F(0) = 0`
- `F(1) = 1`
- 对于 `n >= 2`，`F(n) = F(n-1) + F(n-2)`

#### 动态规划解法：

- **定义状态**：`dp[i]` 表示第 `i` 项斐波那契数。
- **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`
- **初始化**：
  - `dp[0] = 0`
  - `dp[1] = 1`
- **返回值**：最终返回 `dp[n]`。

#### 代码实现（自底向上）：

```javascript
function fibonacci(n) {
  if (n === 0) return 0
  if (n === 1) return 1

  // 初始化 dp 数组
  const dp = new Array(n + 1)
  dp[0] = 0
  dp[1] = 1

  // 动态规划递推计算
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }

  return dp[n]
}

// 示例
console.log(fibonacci(6)) // 输出 8
```

#### 解释：

1. **初始化**：`dp[0] = 0`, `dp[1] = 1`。表示斐波那契数列的前两项。
2. **状态转移**：从 `2` 开始，利用状态转移方程 `dp[i] = dp[i-1] + dp[i-2]` 依次计算每一项。
3. **最终结果**：返回 `dp[n]`，即第 `n` 项斐波那契数。

#### 优化：

- 可以优化空间复杂度，将 `dp` 数组降为常数空间，只需存储前两项的值即可。

#### 优化代码（常数空间）：

```javascript
function fibonacci(n) {
  if (n === 0) return 0
  if (n === 1) return 1

  let prev2 = 0,
    prev1 = 1,
    current

  for (let i = 2; i <= n; i++) {
    current = prev1 + prev2
    prev2 = prev1
    prev1 = current
  }

  return current
}

// 示例
console.log(fibonacci(6)) // 输出 8
```

#### 斐波那契数列动态规划的关键点：

- **最优子结构**：每一项斐波那契数都依赖于前两项的值，因此问题的最优解由子问题的最优解组成。
- **重叠子问题**：多个递归调用会重复计算相同的子问题，通过动态规划可以避免这种重复。

### 动态规划的典型应用场景：

1. **序列问题**：
   - 如最长上升子序列、最长公共子序列等。
2. **背包问题**：
   - 如 0-1 背包问题、完全背包问题等。
3. **路径问题**：
   - 如最短路径问题、网格最小路径和等。
4. **股票交易问题**：
   - 如买卖股票的最佳时机等。
